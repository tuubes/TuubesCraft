package org.tuubes.craft.mc1_12.play.clientbound

import com.electronwill.niol.{NiolInput, NiolOutput}
import org.tuubes.network._

/** Packet class auto-generated by DataTractor */
final class ChunkDataPacket(var chunkX: Int, var chunkZ: Int, var ground-upContinuous: Boolean, var primaryBitMask: Int, var data: Array[Byte], var blockEntities: Array[TagCompound]) extends Packet {
  override def write(out: NiolOutput): Unit {
    out.putInt(chunkX)
    out.putInt(chunkZ)
    out.putBoolean(ground-upContinuous)
    out.putVarint(primaryBitMask)
    out.putVarint(data.length)
    out.putBytes(data)
    out.putVarint(blockEntities.length)
    var i_blockEntities = 0
    while (i_blockEntities < blockEntities.length) {
      // TODO write blockEntities(i_blockEntities)
      i_blockEntities += 1
    }
  }
	
  override def id = ChunkDataPacket.id

	
}
object ChunkDataPacket extends PacketObj[ChunkDataPacket] {
  override val id = 32
	
  override def read(in: NiolOutput): ChunkDataPacket {
    val chunkX = in.getInt()
    val chunkZ = in.getInt()
    val ground-upContinuous = in.getBoolean()
    val primaryBitMask = in.getVarint()
    val dataLength = in.getVarint()
    val data = in.getBytes(dataLength)
    val blockEntitiesLength = in.getVarint()
    var i_blockEntities = 0
    val blockEntities = new Array[TagCompound](blockEntitiesLength)
    while (i_blockEntities < blockEntitiesLength) {
      // TODO read blockEntities(i_blockEntities)
      i_blockEntities += 1
    }
    new ChunkDataPacket(chunkX, chunkZ, ground-upContinuous, primaryBitMask, data, blockEntities)
  }
}
/** Packet builder auto-generated by DataTractor */
final class ChunkDataPacketBuilder[P <: ChunkDataPacket] extends PacketBuilder[ChunkDataPacket, Complete] {
  private[this] var chunkX: Int = _
  private[this] var chunkZ: Int = _
  private[this] var ground-upContinuous: Boolean = _
  private[this] var primaryBitMask: Int = _
  private[this] var data: Array[Byte] = _
  private[this] var blockEntities: Array[TagCompound] = _

  def withChunkX(chunkX: Int): ChunkDataPacketBuilder[P with ChunkX] = {
    this.chunkX = chunkX
    this.asInstanceOf[ChunkDataPacketBuilder[P with ChunkX]]
  }

  def withChunkZ(chunkZ: Int): ChunkDataPacketBuilder[P with ChunkZ] = {
    this.chunkZ = chunkZ
    this.asInstanceOf[ChunkDataPacketBuilder[P with ChunkZ]]
  }

  def withGround-UpContinuous(ground-upContinuous: Boolean): ChunkDataPacketBuilder[P with Ground-UpContinuous] = {
    this.ground-upContinuous = ground-upContinuous
    this.asInstanceOf[ChunkDataPacketBuilder[P with Ground-UpContinuous]]
  }

  def withPrimaryBitMask(primaryBitMask: Int): ChunkDataPacketBuilder[P with PrimaryBitMask] = {
    this.primaryBitMask = primaryBitMask
    this.asInstanceOf[ChunkDataPacketBuilder[P with PrimaryBitMask]]
  }

  def withData(data: Array[Byte]): ChunkDataPacketBuilder[P with Data] = {
    this.data = data
    this.asInstanceOf[ChunkDataPacketBuilder[P with Data]]
  }

  def withBlockEntities(blockEntities: Array[TagCompound]): ChunkDataPacketBuilder[P with BlockEntities] = {
    this.blockEntities = blockEntities
    this.asInstanceOf[ChunkDataPacketBuilder[P with BlockEntities]]
  }

  override def build()(implicit evidence: P =:= Complete) {
    new ChunkDataPacket(chunkX, chunkZ, ground-upContinuous, primaryBitMask, data, blockEntities)
  }
}
object ChunkDataPacketBuilder {
  sealed trait ChunkX
  sealed trait ChunkZ
  sealed trait Ground-UpContinuous
  sealed trait PrimaryBitMask
  sealed trait Data
  sealed trait BlockEntities
  type Complete = ChunkDataPacketBuilder with ChunkX with ChunkZ with Ground-UpContinuous with PrimaryBitMask with Data with BlockEntities
}

package org.tuubes.craft.mc1_12.play.clientbound

import ChunkDataPacketBuilder._
import com.electronwill.niol.compatibility._
import com.electronwill.niol.{NiolInput, NiolOutput}
import com.electronwill.nbj.TagCompound
import org.tuubes.core.network._
import org.tuubes.craft.CraftAttach

/** Packet class auto-generated by DataTractor */
final class ChunkDataPacket(var chunkX: Int, var chunkZ: Int, var groundUpContinuous: Boolean, var primaryBitMask: Int, var data: Array[Byte], var blockEntities: Array[TagCompound]) extends Packet[CraftAttach] {
  override def write(out: NiolOutput): Unit = {
    out.putInt(chunkX)
    out.putInt(chunkZ)
    out.putBool(groundUpContinuous)
    out.putVarint(primaryBitMask)
    out.putVarint(data.length)
    out.putBytes(data)
    out.putVarint(blockEntities.length)
    var i_blockEntities = 0
    while (i_blockEntities < blockEntities.length) {
      // TODO write blockEntities(i_blockEntities)
      i_blockEntities += 1
    }
  }
	
  override def obj = ChunkDataPacket

	
}
object ChunkDataPacket extends PacketObj[CraftAttach, ChunkDataPacket] {
  override val id = 32
	
  override def read(in: NiolInput): ChunkDataPacket = {
    val chunkX = in.getInt()
    val chunkZ = in.getInt()
    val groundUpContinuous = in.getBool()
    val primaryBitMask = in.getVarint()
    val dataLength = in.getVarint()
    val data = in.getBytes(dataLength)
    val blockEntitiesLength = in.getVarint()
    var i_blockEntities = 0
    val blockEntities = new Array[TagCompound](blockEntitiesLength)
    while (i_blockEntities < blockEntitiesLength) {
      // TODO read blockEntities(i_blockEntities)
      i_blockEntities += 1
    }
    new ChunkDataPacket(chunkX, chunkZ, groundUpContinuous, primaryBitMask, data, blockEntities)
  }
}
/** Packet builder auto-generated by DataTractor */
final class ChunkDataPacketBuilder[P <: ChunkDataPacket] extends PacketBuilder[ChunkDataPacket, P =:= Complete] {
  private[this] var chunkX: Int = _
  private[this] var chunkZ: Int = _
  private[this] var groundUpContinuous: Boolean = _
  private[this] var primaryBitMask: Int = _
  private[this] var data: Array[Byte] = _
  private[this] var blockEntities: Array[TagCompound] = _

  def withChunkX(chunkX: Int): ChunkDataPacketBuilder[P with ChunkX] = {
    this.chunkX = chunkX
    this.asInstanceOf[ChunkDataPacketBuilder[P with ChunkX]]
  }

  def withChunkZ(chunkZ: Int): ChunkDataPacketBuilder[P with ChunkZ] = {
    this.chunkZ = chunkZ
    this.asInstanceOf[ChunkDataPacketBuilder[P with ChunkZ]]
  }

  def withGroundUpContinuous(groundUpContinuous: Boolean): ChunkDataPacketBuilder[P with GroundUpContinuous] = {
    this.groundUpContinuous = groundUpContinuous
    this.asInstanceOf[ChunkDataPacketBuilder[P with GroundUpContinuous]]
  }

  def withPrimaryBitMask(primaryBitMask: Int): ChunkDataPacketBuilder[P with PrimaryBitMask] = {
    this.primaryBitMask = primaryBitMask
    this.asInstanceOf[ChunkDataPacketBuilder[P with PrimaryBitMask]]
  }

  def withData(data: Array[Byte]): ChunkDataPacketBuilder[P with Data] = {
    this.data = data
    this.asInstanceOf[ChunkDataPacketBuilder[P with Data]]
  }

  def withBlockEntities(blockEntities: Array[TagCompound]): ChunkDataPacketBuilder[P with BlockEntities] = {
    this.blockEntities = blockEntities
    this.asInstanceOf[ChunkDataPacketBuilder[P with BlockEntities]]
  }

  override def build()(implicit evidence: P =:= Complete) = {
    new ChunkDataPacket(chunkX, chunkZ, groundUpContinuous, primaryBitMask, data, blockEntities)
  }
}
object ChunkDataPacketBuilder {
  sealed trait ChunkX
  sealed trait ChunkZ
  sealed trait GroundUpContinuous
  sealed trait PrimaryBitMask
  sealed trait Data
  sealed trait BlockEntities
  type Complete = ChunkDataPacket with ChunkX with ChunkZ with GroundUpContinuous with PrimaryBitMask with Data with BlockEntities
}

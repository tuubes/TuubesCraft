package org.tuubes.craft.mc1_12.status.serverbound

import RequestPacketBuilder._
import com.electronwill.nightconfig.json.JsonFormat
import com.electronwill.niol.buffer.provider.HeapNioAllocator
import com.electronwill.niol.{NiolInput, NiolOutput}
import org.tuubes.core.TuubesServer
import org.tuubes.craft.CraftAttach
import org.tuubes.core.network._
import org.tuubes.craft.mc1_12.status.clientbound.ResponsePacket

/** Packet class auto-generated by DataTractor */
final class RequestPacket() extends Packet[CraftAttach] {
  override def write(out: NiolOutput): Unit = {

  }

  override def obj = RequestPacket
}
object RequestPacket extends PacketObj[CraftAttach, RequestPacket] {
  override val id = 0

  override def read(in: NiolInput): RequestPacket = {

    new RequestPacket()
  }

  override def handle(packet: Complete, client: CraftAttach): Unit = {
    super.handle(packet, client)
    val f = JsonFormat.minimalInstance()
    val json = f.createConfig()
    json.set("version.name", "1.12.2")
    json.set("version.protocol", 340)
    json.set("players.max", 100)
    json.set("players.online", 10)
    json.set("description.text", s"Tuubes ${TuubesServer.Version} :3")
    val jsonString = f.createWriter().writeToString(json)
    val response = new ResponsePacket(jsonString)
    val buffer = HeapNioAllocator.getBuffer(jsonString.length+16)
    response.write(buffer)
    client.write(buffer)
  }
}
/** Packet builder auto-generated by DataTractor */
final class RequestPacketBuilder[P <: RequestPacket] extends PacketBuilder[RequestPacket, P =:= Complete] {
  override def build()(implicit evidence: P =:= Complete) = {
    new RequestPacket()
  }
}
object RequestPacketBuilder {
  type Complete = RequestPacket
}

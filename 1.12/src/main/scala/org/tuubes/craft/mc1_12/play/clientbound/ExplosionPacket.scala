package org.tuubes.craft.mc1_12.play.clientbound

import com.electronwill.niol.{NiolInput, NiolOutput}
import ExplosionPacketBuilder._
import org.tuubes.craft.CraftAttach
import org.tuubes.core.network._

/** Packet class auto-generated by DataTractor */
final class ExplosionPacket(var x: Float, var y: Float, var z: Float, var radius: Float, var records: Array[???], var playerMotionX: Float, var playerMotionY: Float, var playerMotionZ: Float) extends Packet[CraftAttach] {
  override def write(out: NiolOutput): Unit = {
    out.putFloat(x)
    out.putFloat(y)
    out.putFloat(z)
    out.putFloat(radius)
    out.putInt(records.length)
    var i_records = 0
    while (i_records < records.length) {
      // TODO write records(i_records)
      i_records += 1
    }
    out.putFloat(playerMotionX)
    out.putFloat(playerMotionY)
    out.putFloat(playerMotionZ)
  }
	
  override def obj = ExplosionPacket

	
}
object ExplosionPacket extends PacketObj[CraftAttach, ExplosionPacket] {
  override val id = 28
	
  override def read(in: NiolInput): ExplosionPacket = {
    val x = in.getFloat()
    val y = in.getFloat()
    val z = in.getFloat()
    val radius = in.getFloat()
    val recordsLength = in.getInt()
    var i_records = 0
    val records = new Array[???](recordsLength)
    while (i_records < recordsLength) {
      // TODO read records(i_records)
      i_records += 1
    }
    val playerMotionX = in.getFloat()
    val playerMotionY = in.getFloat()
    val playerMotionZ = in.getFloat()
    new ExplosionPacket(x, y, z, radius, records, playerMotionX, playerMotionY, playerMotionZ)
  }
}
/** Packet builder auto-generated by DataTractor */
final class ExplosionPacketBuilder[P <: ExplosionPacket] extends PacketBuilder[ExplosionPacket, P =:= Complete] {
  private[this] var x: Float = _
  private[this] var y: Float = _
  private[this] var z: Float = _
  private[this] var radius: Float = _
  private[this] var records: Array[???] = _
  private[this] var playerMotionX: Float = _
  private[this] var playerMotionY: Float = _
  private[this] var playerMotionZ: Float = _

  def withX(x: Float): ExplosionPacketBuilder[P with X] = {
    this.x = x
    this.asInstanceOf[ExplosionPacketBuilder[P with X]]
  }

  def withY(y: Float): ExplosionPacketBuilder[P with Y] = {
    this.y = y
    this.asInstanceOf[ExplosionPacketBuilder[P with Y]]
  }

  def withZ(z: Float): ExplosionPacketBuilder[P with Z] = {
    this.z = z
    this.asInstanceOf[ExplosionPacketBuilder[P with Z]]
  }

  def withRadius(radius: Float): ExplosionPacketBuilder[P with Radius] = {
    this.radius = radius
    this.asInstanceOf[ExplosionPacketBuilder[P with Radius]]
  }

  def withRecords(records: Array[???]): ExplosionPacketBuilder[P with Records] = {
    this.records = records
    this.asInstanceOf[ExplosionPacketBuilder[P with Records]]
  }

  def withPlayerMotionX(playerMotionX: Float): ExplosionPacketBuilder[P with PlayerMotionX] = {
    this.playerMotionX = playerMotionX
    this.asInstanceOf[ExplosionPacketBuilder[P with PlayerMotionX]]
  }

  def withPlayerMotionY(playerMotionY: Float): ExplosionPacketBuilder[P with PlayerMotionY] = {
    this.playerMotionY = playerMotionY
    this.asInstanceOf[ExplosionPacketBuilder[P with PlayerMotionY]]
  }

  def withPlayerMotionZ(playerMotionZ: Float): ExplosionPacketBuilder[P with PlayerMotionZ] = {
    this.playerMotionZ = playerMotionZ
    this.asInstanceOf[ExplosionPacketBuilder[P with PlayerMotionZ]]
  }

  override def build()(implicit evidence: P =:= Complete) = {
    new ExplosionPacket(x, y, z, radius, records, playerMotionX, playerMotionY, playerMotionZ)
  }
}
object ExplosionPacketBuilder {
  sealed trait X
  sealed trait Y
  sealed trait Z
  sealed trait Radius
  sealed trait Records
  sealed trait PlayerMotionX
  sealed trait PlayerMotionY
  sealed trait PlayerMotionZ
  type Complete = ExplosionPacket with X with Y with Z with Radius with Records with PlayerMotionX with PlayerMotionY with PlayerMotionZ
}

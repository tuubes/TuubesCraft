package org.tuubes.craft.mc1_12.play.clientbound

import com.electronwill.niol.{NiolInput, NiolOutput}
import org.tuubes.network._

/** Packet class auto-generated by DataTractor */
final class MapPacket(var itemDamage: Int, var scale: Byte, var trackingPosition: Boolean, var iconCount: Int, var directionAndType: Byte, var x: Byte, var z: Byte, var columns: Byte, var rows: Option[Byte], var x: Option[Byte], var z: Option[Byte], var length: Option[Int], var data: Option[Array[Int]]) extends Packet {
  override def write(out: NiolOutput): Unit {
    out.putVarint(itemDamage)
    out.putByte(scale)
    out.putBoolean(trackingPosition)
    out.putVarint(iconCount)
    out.putByte(directionAndType)
    out.putByte(x)
    out.putByte(z)
    out.putByte(columns)
    if (rows.isDefined) {
      out.putByte(rows)
    }
    if (x.isDefined) {
      out.putByte(x)
    }
    if (z.isDefined) {
      out.putByte(z)
    }
    if (length.isDefined) {
      out.putVarint(length)
    }
    if (data.isDefined) {
      var i_data = 0
    while (i_data < data.length) {
      // TODO write data(i_data)
      i_data += 1
    }
    }
  }
	
  override def id = MapPacket.id

	
}
object MapPacket extends PacketObj[MapPacket] {
  override val id = 36
	
  override def read(in: NiolOutput): MapPacket {
    val itemDamage = in.getVarint()
    val scale = in.getByte()
    val trackingPosition = in.getBoolean()
    val iconCount = in.getVarint()
    val directionAndType = in.getByte()
    val x = in.getByte()
    val z = in.getByte()
    val columns = in.getByte()
    // TODO read rows
    // TODO read x
    // TODO read z
    // TODO read length
    // TODO read data
    new MapPacket(itemDamage, scale, trackingPosition, iconCount, directionAndType, x, z, columns, rows, x, z, length, data)
  }
}
/** Packet builder auto-generated by DataTractor */
final class MapPacketBuilder[P <: MapPacket] extends PacketBuilder[MapPacket, Complete] {
  private[this] var itemDamage: Int = _
  private[this] var scale: Byte = _
  private[this] var trackingPosition: Boolean = _
  private[this] var iconCount: Int = _
  private[this] var directionAndType: Byte = _
  private[this] var x: Byte = _
  private[this] var z: Byte = _
  private[this] var columns: Byte = _
  private[this] var rows: Option[Byte] = _
  private[this] var x: Option[Byte] = _
  private[this] var z: Option[Byte] = _
  private[this] var length: Option[Int] = _
  private[this] var data: Option[Array[Int]] = _

  def withItemDamage(itemDamage: Int): MapPacketBuilder[P with ItemDamage] = {
    this.itemDamage = itemDamage
    this.asInstanceOf[MapPacketBuilder[P with ItemDamage]]
  }

  def withScale(scale: Byte): MapPacketBuilder[P with Scale] = {
    this.scale = scale
    this.asInstanceOf[MapPacketBuilder[P with Scale]]
  }

  def withTrackingPosition(trackingPosition: Boolean): MapPacketBuilder[P with TrackingPosition] = {
    this.trackingPosition = trackingPosition
    this.asInstanceOf[MapPacketBuilder[P with TrackingPosition]]
  }

  def withIconCount(iconCount: Int): MapPacketBuilder[P with IconCount] = {
    this.iconCount = iconCount
    this.asInstanceOf[MapPacketBuilder[P with IconCount]]
  }

  def withDirectionAndType(directionAndType: Byte): MapPacketBuilder[P with DirectionAndType] = {
    this.directionAndType = directionAndType
    this.asInstanceOf[MapPacketBuilder[P with DirectionAndType]]
  }

  def withX(x: Byte): MapPacketBuilder[P with X] = {
    this.x = x
    this.asInstanceOf[MapPacketBuilder[P with X]]
  }

  def withZ(z: Byte): MapPacketBuilder[P with Z] = {
    this.z = z
    this.asInstanceOf[MapPacketBuilder[P with Z]]
  }

  def withColumns(columns: Byte): MapPacketBuilder[P with Columns] = {
    this.columns = columns
    this.asInstanceOf[MapPacketBuilder[P with Columns]]
  }

  def withRows(rows: Option[Byte]): MapPacketBuilder[P with Rows] = {
    this.rows = rows
    this.asInstanceOf[MapPacketBuilder[P with Rows]]
  }

  def withX(x: Option[Byte]): MapPacketBuilder[P with X] = {
    this.x = x
    this.asInstanceOf[MapPacketBuilder[P with X]]
  }

  def withZ(z: Option[Byte]): MapPacketBuilder[P with Z] = {
    this.z = z
    this.asInstanceOf[MapPacketBuilder[P with Z]]
  }

  def withLength(length: Option[Int]): MapPacketBuilder[P with Length] = {
    this.length = length
    this.asInstanceOf[MapPacketBuilder[P with Length]]
  }

  def withData(data: Option[Array[Int]]): MapPacketBuilder[P with Data] = {
    this.data = data
    this.asInstanceOf[MapPacketBuilder[P with Data]]
  }

  override def build()(implicit evidence: P =:= Complete) {
    new MapPacket(itemDamage, scale, trackingPosition, iconCount, directionAndType, x, z, columns, rows, x, z, length, data)
  }
}
object MapPacketBuilder {
  sealed trait ItemDamage
  sealed trait Scale
  sealed trait TrackingPosition
  sealed trait IconCount
  sealed trait DirectionAndType
  sealed trait X
  sealed trait Z
  sealed trait Columns
  sealed trait Rows
  sealed trait X
  sealed trait Z
  sealed trait Length
  sealed trait Data
  type Complete = MapPacketBuilder with ItemDamage with Scale with TrackingPosition with IconCount with DirectionAndType with X with Z with Columns with Rows with X with Z with Length with Data
}
